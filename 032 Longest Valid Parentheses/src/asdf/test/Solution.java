package asdf.test;

public class Solution {

	/**
	 * (最长合法括号)Given a string containing just the characters '(' and ')', find
	 * the length of the longest valid (well-formed) parentheses substring.
	 * 
	 * For "(()", the longest valid parentheses substring is "()", which has
	 * length = 2.
	 * 
	 * Another example is ")()())", where the longest valid parentheses
	 * substring is "()()", which has length = 4.
	 */

	public int longestValidParentheses(String s) {
		int longest = 0;

		int sLen = s.length();
		int[] f = new int[sLen];// 以i结尾的子串最大长度
		int  j;

		for (int i = 1; i < sLen; i++) {
			if (s.charAt(i) == ')') {//必定结尾为)
				j = i - f[i - 1] - 1;//!!!计算上一个元素的起始!!!!()正好包含在初始中
				if(j>=0&&s.charAt(j)=='(')//!!!(只可能出现在此位置上，如果往后，f[i-1]长度加1，必定不满足；如果往前，j位置上是),前面有个(,f[i-1]的长度必定可扩展。
				{
					f[i]=f[i-1]+2;
					if(j-1>0)
						f[i]+=f[j-1];
				}				
			}
			if (f[i] > longest)
				longest = f[i];
		}
		return longest;
	}

	public static void main(String[] args) {
		Solution solution = new Solution();
		System.out
				.println(solution
						.longestValidParentheses("())()()(())((()(()()(((()))((((())((()(())()())(()((((()))()(()))(())()(())(()(((((())((((((()())())(()(()((())()))(()))))))()(()))((((())()()()))()()()(((()(()())(()()(()(()()(((()))))))()()))())())((()()))))))((()))(((()((())()(()()))((())))()()())))))))()))))(()))))()))()))()((())))((()))(()))))))(((()))))))))()(()()()(())((())()))()()(())))()()))(()())()))(((()())()))((())((((()))(()(()(()()()(((())()(((((()))((()(((((())(()()))((((((((()(()(()(()(())))(())(()())())(()((((()(())((()(())))(())))()(((((()(()()(())))))))())(())(())(()()(((())))((()))(((((()))))())))()((()))()))))())))))((())(((((()()))((((())))(((()(()(())())(((()(()(()()()())))())()))((()((())())()()()(((())(((((()((((((()((()())))((((())((()(((((((()(()((()()()(()(()())(()(()()((((())))()(((()())))(()()))()(()()()()(((((())(()))))((()))())))()((((((()))())))()(()))(())))((((()())(((((()()())(((((())(()())(()))))()(()()))()))))))())))(((())(()(()()))(()))()(((())))())((((()(((()))))))()(()(()))()()(()()))))))))((()))))))(())((()((()))()))((((((()())))))(()((())((((()))))(()(()()()()(()))()()(()(()))(()()(((((((()())(())(()())((())())()(()())((())()())())(()())))())))(())())())(())((()())(((()()))()))()()))()(()(())((((((((())))()((())((()((((((((((()))))(()(((((())(()(()())())))((())())))))()))(()((()()))((()((())()()()((()(())())((())())(()()(((())))))())()()(()))()())(()(()((())))((((()()(())))())(())(()(()(())())())(()()())()(())())))(()()(((())))((()()(((())()()(()())((((()()(()())(()((((()(()()(()(()(((()((()())(()()))(()((((()(((((()))))()()))(((()((((((()(()()()()())()))(()(())))))((()(((()())())))(((()()))(()(()(((((((()()))(()(())))())()(())())(())(()))(())(()))()()(()()())))))()))()((())(((()((((((((())()()))())))((()())("));
		System.out.println(solution.longestValidParentheses("))()())"));
		System.out.println(solution.longestValidParentheses("(()"));

	}
}
